---
layout: post
---

# Nginx using docker

Run docker image, default page, on port 80
```
docker container run -p 80:80 nginx
```

Add a container name and mount your fileds to default nginx path
`/usr/share/nginx/html` and remove when you stop it
```
docker container run --name nginx --rm -v $(pwd):/usr/share/nginx/html -p 80:80 nginx
```

Test main config
```
docker run --name my-custom-nginx --rm -v $(pwd)/n.conf:/etc/nginx/nginx.conf:ro -p 80:80 nginx
```
Test default config `/etc/nginx/conf.d/default.conf`
```
docker run --name my-custom-nginx --rm -v $(pwd)/d.conf:/etc/nginx/conf.d/default.conf:ro -p 80:80 nginx
docker run --name my-custom-nginx --rm -v $(pwd)/d.conf:/etc/nginx/conf.d/default.conf:ro -v $(pwd):/data/www -p 80:80 nginx
```

Run bash command inside container
```
docker container run -it nginx bash
```
or cat default config
```
docker container run nginx cat /etc/nginx/conf.d/default.conf
```

# NGINX config

http://nginx.org/en/docs/beginners_guide.html

Simple directives ends with `;` semicolon.
Block directives ends with a block `{}` braces and they define context.
Directives outside of any context are considered to be in the `main` context,
like `http` and `events` directives (`location` is inside `server` inside `http`
context).

```
http {
  server {
    listen 80 default_server;
    server_name my.domain.com;
    location / {
      root /data/www;
    }
  }
}
```
`server` blocks are distinguished by ports on which they listen and by server
names.

`location` parametar should match URI in the request header. Server uses the
longest `location path` prefix.

`root` is used as prefix for URI. It could be inside location or server.

`listen` is a port on which to listen, use `default_server` param to set as
default is no other servers is matched by the `server_name`
http://nginx.org/en/docs/http/request_processing.html

http://nginx.org/en/docs/http/server_names.html
`server_name` is used to pick different servers (if nothing matches,
`default_server` or first server will be used). You can prevent access without
host using a empty server_name put it as first or default_server.
Enable health-check path since it is usually accessed by IP address.
```
# Test with a command
# docker run --name my-custom-nginx --rm -v $(pwd)/d.conf:/etc/nginx/conf.d/default.conf:ro -p 80:80 nginx
#
# http://nginx.org/en/docs/http/request_processing.html#how_to_prevent_undefined_server_names
server {
  listen 80 default_server;
  server_name "";
  location / {
    return 444;
  }
  # https://serverfault.com/questions/196929/how-to-reply-with-200-from-nginx-without-serving-a-file
  location /health-check {
    return 200 'gangnam style!';
    add_header Content-Type text/plain;
  }
}
server {
  listen 80;
  server_name dule;
  location / {
    return 200 'dule';
    add_header Content-Type text/plain;
  }
}
```

## ngx http rewrite module

You can use `set $upstream 127.0.0.1:3000;` to define variable and use it in
`proxy_pass http://$upstream;`
http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#set

Config generateor https://www.digitalocean.com/community/tools/nginx
