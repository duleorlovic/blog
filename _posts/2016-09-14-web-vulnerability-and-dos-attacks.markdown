---
layout: post
title: Web vulerability and dos attacks for rails on production Rack attack
---

* [OWASP](https://www.owasp.org/index.php/Category:Attack) nice examples of
attack and vulnerability

~~~
<IMG SRC=/ onerror="console.log('cao. bolje da eskejpujete sadrzaj');location.assign('http://www.iznajmljivanjeprojektoranovisad.in.rs')"></img>
~~~

# DOS attack

* `sudo hping3 -c 10000 -d 120 -S -w 64 -p 21 --flood --rand-source
  myapp.herokuapp.com`
* you can generate authnentication key for http basic authentication with

~~~
auth=`echo -n 'username:password' | openssl base64`
~~~

## Siege

Run 25 concurent users 1 minute with basic http authorization:

~~~
siege myapp.herokuapp.com -c25 -t1M -H "Authorization: Basic
bmalrb2xhb2I6bmlrb2xhamVjYXI="
~~~

## AB

Run 500 requests in 5 threads:

~~~
ab -n 500 -c 5 -H 'Authorization:Basic barb2xhb2I6bmlrb2xhamVjYXI=' http://yourapp.com/
ab -kc 10 -t 10 url # 10 seconds in 10 threads
~~~

# Rack Attack

You can use [rack-attack gem](https://github.com/kickstarter/rack-attack) to
prevent dos attacks. It will allow all requests from `saveflist` and exit.
Otherwise it will ban all requests from `blocklist` and exit. Otherwise it will
check for throttle.  [Example
configuration](https://github.com/kickstarter/rack-attack/wiki/Example-Configuration)

~~~
echo 'rack-attack' >> Gemfile
bundle
sed -i config/application.rb -e '/^  end$/i \
    config.middleware.use Rack::Attack'
~~~

~~~
# config/initializers/rack_attack.rb
module Rack
  class Attack
    # https://github.com/kickstarter/rack-attack/wiki/Example-Configuration
    THROTTLED_BLOCKED_INTERVAL = 1.hour

    # Key: "rack::attack:#{Time.now.to_i/:period}:req/ip:#{req.ip}"
    throttle('req/ip', limit: 300, period: 5.minutes) do |req|
      req.ip unless req.path.starts_with?('/assets')
    end

    # Key: "rack::attack:#{Time.now.to_i/:period}:logins/email:#{req.ip}"
    throttle('logins/email', limit: 5, period: 20.seconds) do |req|
      req.params['user'].try(:[], "email") if req.path == '/users/sign_in' &&
                                              req.post?
    end

    blocklist('blocklist_ips 1.2.3.4') do |req|
      Rails.cache.fetch("blocklist_ips #{req.ip}").present?
    end

    OFFICE_IP = '1.2.3.4'
    blocklist('bad_admin_ip') do |req|
      req.path.start_with?('/admin') && req.ip != OFFICE_IP
    end

    safelist('safelist_ips 1.2.3.4') do |req|
      # if req.ip == "127.0.0.1"
      #   true
      # else
      #   Rails.cache.fetch("safelist_ips #{req.ip}").present?
      # end
      Rails.cache.fetch("safelist_ips #{req.ip}").present?
    end

    self.blocklisted_response = lambda do |env|
      ip = find_ip_from_env(env)
      unless Rails.cache.fetch("notification_block #{ip}").present?
        Rails.cache.write("notification_block #{ip}", true, expires_in: 1.hour)
        ExceptionNotifier.notify_exception(
          Exception.new("ip_blocklist"),
          env: env,
          email_prefix: "just to notify (in this hour) that #{ip} tried again")
      end
      # Using 503 because it may make attacker think that they have successfully
      # DOSed the site. Rack::Attack returns 403 for blocklists by default
      [503, {}, [
        "Your IP address (#{ip}) has been blocked. If you think that this a "\
        "mistake please write to info@xceednet.com"]]
    end

    self.throttled_response = lambda do |env|
      ip = find_ip_from_env(env)
      if ip.present?
        Rails.cache.write("blocklist_ips #{ip}", true,
                          expires_in: THROTTLED_BLOCKED_INTERVAL)
        Rails.logger.info "throttled response: temporary adding #{ip} to "\
        "blocklist_ips"
        ExceptionNotifier.notify_exception(
          Exception.new("ip_throttle"),
          env: env,
          email_prefix: "just info that #{ip} is on blocklist for some time",
          data: {
            help_text: "You can remove this temporary block in rails console "\
            "with this command (note that throttle still works):
            rake rack_attack:remove_from_blocklist_ips[#{ip}]
            ')" }
        )
      else
        Rails.logger.info "throttled response, but do not know ip address"
      end

      # Using 503 because it may make attacker think that they have successfully
      # DOSed the site. Rack::Attack returns 429 for throttling by default
      # [ 503, {}, [body]]
      [503, {}, ["Try later"]]
    end

    def self.find_ip_from_env(env)
      if env["REMOTE_ADDR"].present?
        env["REMOTE_ADDR"]
      else
        # heroku
        env["HTTP_X_FORWARDED_FOR"]
      end
    end
  end
end
~~~

You can test with command:

~~~
ab -n 350 http://localhost:3000
~~~

Default rails cache is file, so you need to `rm -rf tmp/cache` if you want to
test clean situation.

If you receive too much 404 in logs, you can ban ip addreses
<http://marianposaceanu.com/articles/keep-your-rails-logs-free-of-unwanted-noise>
For example block ip address for one day if request is made to
`/{wp-admin|wp-login}`

~~~
# After 1 blocked requests in 10 minutes, block all requests from that IP for 1 day.
Rack::Attack.blocklist('fail2ban pentesters') do |req|
  # `filter` returns truthy value if request fails, or if it's from a previously banned IP so the request is blocked
  Rack::Attack::Fail2Ban.filter(
    "pentesters-#{req.ip}",
    maxretry: 1,
    findtime: 10.minutes,
    bantime: 1.day
  ) do
    # The count for the IP is incremented if the return value is truthy
    req.path.include?('wp-admin') ||
    req.path.include?('wp-login')
  end
end
~~~

# SQL Injection

* [rails-sqli](http://rails-sqli.org/) list of common injections
* external params should be sanitized `where("id = ?", params[:id])` or
`where("id = :id", id: params[:id])`
* with `order` we can not use sanitizations `?` or `:id` method. So do not use
string interpolation since anybody can do anything (drop table, get access). You
can try with adding `limit 1#` (`#` is `%23`
[encoded](http://www.w3schools.com/tags/ref_urlencode.asp)) for example
`?sort=created_at&direction=asc+limit+1%23`. Solution is to use methods that
returns only column names

  ~~~
  # app/controllers/application_controller.rb
  def sort_column
    %w[id name created_at].include?(params[:sort])) ? params[:sort] : "id"
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ?  params[:direction] : "desc"
  end

  def sort_query
    "#{sort_column} #{sort_direction}"
  end

  # use like: User.order(sort_query)
  ~~~

## Tips

* use scoped find, instead of `Order.find params[:id]` use `current_user.orders
find params[:id]`
* use rate limiting, for example facebook password recovery number is 6 digits,
and beta.facebook did not have rate limit, so you can try 1 milin numbers very
quickly
* do not trust the mobile app, for example mobile app make a failed payment and
than change the payment response to be success and send that to server
* if your server is doing curl requests for some user url, than user can set up
sftp or smtp requests to any server and hide itself
* use SHA 256 instead  md5 and SHA 1

<https://github.com/eliotsykes/rails-security-checklist>
<https://github.com/eliotsykes/real-world-rails>

