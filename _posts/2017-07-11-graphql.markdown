---
title: GraphQL
---

We get data with GET request and send sada with POST request with `query` param.
Only problem could be caching since we need different strategy for caching.

http://graphql.org/learn

# Queries

Fields can be string or array, or object (than you can make subselection).
You can pass arguments to fields (like `id: 1`). Argument can be Enumeration
type.

~~~
{
  # queries can have comments
  human(id: 1) {
    name
    height(unit: METER)
  }
}
~~~

response is

~~~
{
  "data: {
    "hero": {
      "name": "My name",
      "height": 4
    }
  }
~~~

If you need several items than you can use aliases

~~~
{
  importantHuman: human(id:1) {
    name
  }
}
~~~

For each alias you can include same set of `credentialsFields` with fragments

~~~
  niceHuman: human(id: 2) {
  ...credentialsFields
  }
  fragment credentialsFields on Character {
    name
  }
~~~

Inline fragments check if returned type is Droid or Human

~~~
query HeroForEpisode($ep: Episode!) {
  hero(episode: $ep) {
    name
    ... on Droid {
      primaryFunction
    }
    ... on Human {
      height
    }
  }
}
~~~

# Variables

Query can have dynamic params which are interpolated on server. Variables has
prefix $ and is followed by type.
Type can be (`Episode` is type): scalar, enum or input object type.
If type ends with `!` than variable is required. Otherwise optional. They can
have default type.

~~~
query HeroNameAndFriends($episode: Episode = 'Default Value')
  hero(episode: $episode) {
    name
    friends {
      name
    }
  }
~~~

Additional JSON

~~~
{
  "episode": "My Episode"
}
~~~


# Directives

Dinamically include fields with `@include(if: $my_var)` or `@skip(if: ...)`.
This was we can conditionally add some fields.

~~~
query Hero($episode: Episode, $withFriends: Boolean!) {
  hero(episode: $episode) {
    name
    friends @include(if: $withFriends) {
      name
    }
  }
}
~~~

# Mutations

When sending data, we use `mutation`. They run in sequence, one by one (query
run in parallel).

~~~
mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {
  createReview(episode: $ep, review: $review) {
    stars
    commentary
  }
}
~~~

data

~~~
{
  "ep": "Episode Jedi",
  "review": {
    "stars": 5,
    "commentary": "My comment"
  }
}
~~~

# Introspection

[learn](http://graphql.org/learn/introspection/)
__type, __fields

Permissions:

live queries

subscriptions
https://www.netguru.co/blog/grapghql-vs-rest
https://www.howtographql.com/
https://www.compose.com/articles/use-all-the-databases-part-1/
https://www.youtube.com/watch?v=UBGzsb2UkeY&feature=youtu.be
