---
layout: post
---

# Installation

Integration with rails
```
rails new hello_vue --webpack=vue
```
this will add `vue`, `vue-loader` and `vue-template-compiler` to package.json
and create `app/javascript/packs/vue.js` and `app/javascript/app.vue` (and
some conf file `config/webpack/loaders/vue.js` and update
`config/webpack/environment.js`).
Run `bin/webpack-dev-server` and `rails s` and edit
```
# app/javascript/packs/vue.js
import Vue from 'vue/dist/vue.esm'
import App from '../app.vue'

document.addEventListener('DOMContentLoaded', () => {
  const app = new Vue({
    el: '#hello',
    data: {
      message: "Can you say hello?"
    },
    components: { App }
  })
})
```


# Basic directive helpers

~~~
<div id='app'>
  {{ message }}
  <input v-model='message'>
  <ul>
    <li v-for='item in items' :key='item'>
      {{ item }}
    </li>
  </ul>
</div>
~~~

* mustaches `{ { message }}` can be used only as inner block (not html
  attributes, they need v-bind directive so instead `<img source='{ {}}'>` use
  `<img :src='comment.image'>`). Use ternary expression instead `if` flow. Can
  not use statement like `a=1`.
* For html attributes you have to use `<div v-bind:id='dynamicId'></div>`. When
  boolean atribute is `true`, attribute will show up. When it is `false`,
  `null`, `undefined` it hides that attribute for example `<button
  v-bind:disabled='isButtonDisabled'>B</button>`. Shorthand for `v-bind:` is `:`
  For `class` and `style` attribute you can also use object or array syntax
  ```
    <div :class='{ active: isActive, 'text-danger': hasError }'></div>
    <div :class='[ isActive ? 'active' : '', hasError ? 'text-danger': '' ]'></div>
  ```
* model `v-model='message'` is used for two way binding
  ```
  <p>{{ message }}</p>
  <input v-model="message">
  ```
* conditional `v-if='seen'` directive to render block. Also supports else that
  immediatelly follows `v-if`.
  ```
  <h1 v-if="awesome">Vue is awesome!</h1>
  <h1 v-else>Oh no ðŸ˜¢</h1>
  ```
  You can attach to `<template v-if='ok'` to wrap other elements and
  `<template>` itself will not be rendered.
  `v-show` will always render, but it uses `display: none` css property to hide
  (so `v-show` has higher initial render cost but no cost for show hide since
  event listeners and child components inside no need to be destroyed/created).
  Use `v-else-if` like switch case statement.
  Use `key` to distinguish between different elements, if you do not want them
  to share same value. For example, changing loginType will change only
  placeholder, but value will be the same, so we need different `key`.
  ```
  <template v-if="loginType === 'username'">
    <label>Username</label>
    <input placeholder="Enter your username" key="username-input">
  </template>
  <template v-else>
    <label>Email</label>
    <input placeholder="Enter your email address" key="email-input">
  </template>
  ```
* in loops `v-for='item in items'` you need a key (which is uniq) so it keeps
  track of changes between dom and virtual dom. `v-bind:key='item.id'` or
  shorthand `:key='item.id'`. You can get the index also
  ```
  <li v-for='(item, index) in items'>
    {{ index }}. {{ item.message }}
  </li>
  ```
  You can iterate object properties and also index
  ```
  <li v-for='(value, name, index) in object'>
    {{ index }}. {{ name }}: {{ value }}
  </li>
  ```
  Use `key` attribute so updating does not only patch inline el, but completelly
  remove/create `<div v-for="item in items" v-bind:key="item.id">`.
  You can mutate `items` array with `push()`, `pop()`, `sort()`... and replace
  with new array with `filter()`, `concat()` or `slice()`.
* `<span v-once>{ { message }}</span>` will render only once even you change
  data for inside model interpolation `{ { message }}`
* `<span v-html='rawHtml'></span>` will output without html encoding
* events `v-on:click='shuffle'` or shorthand `@click='shuffle'`. You can use
  modifiers like `<form v-on:submit.prevent='onSubmit'>` which call
  `preventDefault()` on triggered event


# Vue instance

~~~
var vm = new Vue({
  el: '#example',
  data: {
    asd: 1 // you can access data with `vm.asd`
  },
  // lifecycle hooks created, mounted, updated, destroyed
  created: function() {},
  computed: {
    // getters for computed values are like methods/helpers, but result is
    // chached as long as dependencies are not changed (message is not updated).
    // `Date.now()` is not reactive dependency.
    reverseMessage: function() {
      return this.message.split('').reverse().join('')
    },
    // computed property can also define a setter `vm.fullName = 'Joe Doe'
    fullName: {
      get: function() {
        return this.firstName + ' ' + this.lastName
      },
      set: function(newValue) {
        var names = newValue.split(' ')
        this.firstName = names[0]
        this.lastName = names[names.length - 1]
      }
    }

  },
  methods: {
    reverseMessageAlwaysCalculated: function() {
      return this.message.split('').reverse().join('')
    }
  },
  watch: {
    // It is easier to use computed property than to watch for all changes on
    // dependent properties for example FullName depends on First and Last name
    firstName: function(val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function(val) {
      this.fullName = this.firstName + ' ' + val
    }
  }

})

vm.asd // => 1
vm.asd = 2 // reactiveness in action will update data.asd == 2
vm.non_bind = 1 // this was not defined at time of instantiating so no update
vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch is an instance method
vm.$watch('a', function (newValue, oldValue) {
  // This callback will be called when `vm.a` changes
})

~~~

Do not use arrow functions since `this` will not be bound to view instance.

# Animations

~~~
<transition-group tag='ul name='items'>
</transition-group>
~~~

~~~
.items-move {
  transition: transform 0.5s ease;
}
~~~

# Components

Template for component can be referenced with id or written inline. Pass data to
components with `props`, that are 'attributes' for components. They are passed
with `v-bind:name_of_attribute='value_of_attribute'`

~~~
Vue.component('AppComponent', {
  template: '#componentTemplate',
  props: ['comment']
})
~~~

~~~
<ul>
  <li is='app-component' v-for='comment in comments' :key='comment'
:comment='comment'></li>
</ul>
<script type='text/x-template' id='componentTemplate'>
  <li>
    {{ comment.text }}
  </li>
</script>
~~~

# Vue cli

~~~
# yarn will install old ~2 version
# yarn global add @vue/cli
npm install -g @vue/cli

vue create my-project
~~~

# Rails engine

https://github.com/basemate/matestack-ui-core

TODO
https://blog.codeship.com/vuejs-as-a-frontend-for-rails/
https://gorails.com/series/using-vuejs-with-rails
https://mkdev.me/en/posts/rails-5-vue-js-how-to-stop-worrying-and-love-the-frontend



https://vuejs.org/v2/style-guide/
https://github.com/aarondfrancis/vue-model
http://quasar-framework.org/
https://www.reddit.com/r/javascript/comments/6v1ki7/weex_vs_framework7_vs_quasar/
https://blog.logrocket.com/an-imperative-guide-to-forms-in-vue-js-7536bfa374e0
<https://vuejsdevelopers.com/2017/10/23/vue-js-tree-menu-recursive-components/>
https://www.thepolyglotdeveloper.com/2017/11/router-navigate-pages-vuejs-application/
https://www.classandobjects.com/tutorial/using_vue_js_with_rails
https://docs.gitlab.com/ee/development/fe_guide/vue.html#testing-vuex
https://www.thepolyglotdeveloper.com/2017/11/pass-data-between-routes-vuejs-web-application/
https://github.com/calirojas506/vue-inspector
https://engineering.doximity.com/articles/five-traps-to-avoid-while-unit-testing-vue-js
https://wyeworks.com/blog/2018/1/16/Testing-Vuejs-in-Rails-with-Webpacker-and-Jest
https://alligator.io/vuejs/vue-parceljs/
http://epic-spinners.epicmax.co/#/
https://blog.codeship.com/vuejs-components-with-coffeescript-for-rails/
https://github.com/epicmaxco/vuestic-admin

